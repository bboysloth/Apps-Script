/**
 * @file Meeting Tagger Tool v2.6.1
 * @description CRITICAL LOGIC FIX.
 * 1. FIX: The "Auto-Tagger" now correctly populates 'Suggested' (Col G) vs 'Original' (Col M),
 * which makes the 'Synced' (Col H) formula turn FALSE as intended.
 * 2. FIX: The 'Apply Changes' function now correctly detects changes to the
 * 'SE Lead' and 'In Person' checkboxes.
 * 3. FIX: The 'Update Tag Dropdowns & Colors' function is fixed. It now correctly
 * re-applies the conditional formatting rules for the colored chips in Col G.
 * @version 2.6.1
 */

// =================================================================
// #region 1. SPREADSHEET UI & MENU CREATION
// =================================================================
function onOpen() {
  SpreadsheetApp.getUi()
      .createMenu('Meeting Tools')
      .addItem('Refresh Untagged List', 'findEventsMissingTag')
      .addSeparator()
      .addItem('Apply Changes to Calendar', 'applyBatchChanges')
      .addSeparator()
      .addItem('Generate Dashboard', 'generateDashboard')
      .addSeparator()
      .addItem('Config: Update Quarter List', 'updateQuarterDropdown')
      .addItem('Config: Update Tag Dropdowns & Colors', 'updateTagDropdownsAndColors')
      .addItem('Config: Validate Tag Keywords', 'validateTagKeywords')
      .addItem('Config: Save & Refresh', 'saveConfigAndRun')
      .addToUi();
}
// #endregion

// =================================================================
// #region 2. SCRIPT ENTRY POINTS
// =================================================================
function handleEdit(e) {
  updateMeetingTag(e, true); 
}

function applyBatchChanges() {
  updateMeetingTag(null, false); 
}

function saveConfigAndRun() {
  try {
    SpreadsheetApp.flush();
    findEventsMissingTag();
    const file = SpreadsheetApp.getActiveSpreadsheet();
    const triggers = ScriptApp.getProjectTriggers();
    const minutes = parseInt(getConfig("MinutesInterval"), 10);

    triggers.forEach(trigger => {
      const handler = trigger.getHandlerFunction();
      if (handler === 'findEventsMissingTag') {
        ScriptApp.deleteTrigger(trigger);
      }
    });

    if (minutes > 0) {
      ScriptApp.newTrigger('findEventsMissingTag').timeBased().everyMinutes(minutes).create();
    }
    ScriptApp.newTrigger('findEventsMissingTag').forSpreadsheet(file).onOpen().create();
    SpreadsheetApp.getActiveSpreadsheet().toast("Configuration saved and list refreshed.");
  } catch (e) {
    SpreadsheetApp.getUi().alert(e.message);
  }
}
// #endregion

// =================================================================
// #region 3. CORE LOGIC FUNCTIONS
// =================================================================

function findEventsMissingTag() {
    const file = SpreadsheetApp.getActiveSpreadsheet();
    try {
        // --- 1. Configuration ---
        const daysBack = parseInt(getConfig("DaysBack"), 10);
        const daysAhead = parseInt(getConfig("DaysAhead"), 10);
        const selectedQuarter = getConfig("QuarterOverride");
        const ignorePhrases = (getConfig("IgnorePhrases") || "").split(",").map(s => s.trim()).filter(Boolean);
        const ignoreExact = (getConfig("IgnoreExactTitles") || "").split(",").map(s => s.trim()).filter(Boolean);
        const ignoreFromEmails = (getConfig("IgnoreFromEmails") || "").split(",").map(s => s.trim()).filter(Boolean);
        const ignoreToEmails = (getConfig("IgnoreToEmails") || "").split(",").map(s => s.trim()).filter(Boolean);
        const externalFilter = (getConfig("ExternalAttendees") || "false").toString().toLowerCase() === "true";
        const seTaggingMode = (getConfig("SETagMode") || "false").toString().toLowerCase() === "true";
        const showTaggedMeetings = (getConfig("ShowTaggedMeetings") || "false").toString().toLowerCase() === "true";
        const modifier = getConfig("InPersonModifier");
        const seLeadTagText = getConfig("SELeadTagText");
        const tagPrefix = "Verkada Meeting Tag: ";

        const tagsSheet = file.getSheetByName("Tags");
        const tagsData = tagsSheet.getRange("B2:E" + tagsSheet.getLastRow()).getValues();
        const tagColorRange = tagsSheet.getRange("C2:C" + tagsSheet.getLastRow());
        const tagBackgrounds = tagColorRange.getBackgrounds();
        
        const tagMap = new Map(tagsData.map(row => [row[2].trim().replace(";", ""), row[1]]));
        const keywordMap = new Map();
        tagsData.forEach(row => {
            if (row[1] && row[3]) {
                row[3].split(',').map(k => k.trim().toLowerCase()).filter(String).forEach(k => {
                    if (keywordMap.has(k) && keywordMap.get(k) !== row[1] && keywordMap.get(k) !== "CONFLICT") {
                        keywordMap.set(k, "CONFLICT");
                    } else if (!keywordMap.has(k)) {
                        keywordMap.set(k, row[1]);
                    }
                });
            }
        });
        
        // --- 2. Date Logic ---
        let start, end;
        if (selectedQuarter && selectedQuarter !== "" && selectedQuarter !== "None") {
            const parts = selectedQuarter.match(/FY(\d{2})\s*Q(\d)/);
            if (!parts) throw new Error(`Invalid quarter format: "${selectedQuarter}".`);
            const dates = _getDatesForVerkadaFQ(parseInt(parts[1], 10) + 2000, parseInt(parts[2], 10));
            start = dates.start; end = dates.end;
        } else {
            start = new Date(); start.setHours(0, 0, 0, 0); start.setDate(start.getDate() - daysBack);
            end = new Date(); end.setHours(23, 59, 59, 999); end.setDate(end.getDate() + daysAhead);
        }
        
        // --- 3. Fetch Events ---
        const calendarId = CalendarApp.getDefaultCalendar().getId();
        let allEvents = [], pageToken = null;
        do {
          const response = Calendar.Events.list(calendarId, { timeMin: start.toISOString(), timeMax: end.toISOString(), singleEvents: true, orderBy: 'startTime', maxResults: 2500, pageToken: pageToken });
          if (response.items) allEvents = allEvents.concat(response.items);
          pageToken = response.nextPageToken;
        } while (pageToken);

        // --- 4. Process Events ---
        const events = allEvents;
        const noTagMeetings = [], aeTaggedMeetings = [], fullyTaggedMeetings = [];

        for (const event of events) {
            if (event.start.date) continue;
            if (!event.summary) continue;
            const title = event.summary;
            if (ignoreExact.includes(title) || ignorePhrases.some(p => title.includes(p))) continue;
            const organizerEmail = event.organizer ? event.organizer.email : (event.creator ? event.creator.email : '');
            if (organizerEmail.toLowerCase().endsWith('@group.calendar.google.com')) continue;

            const attendees = (event.attendees || []).map(a => a.email).filter(Boolean);
            const allParticipants = [...new Set([organizerEmail, ...attendees])];
            const isInternalEntity = email => email && (email.toLowerCase().endsWith("@verkada.com") || email.toLowerCase().endsWith("@resource.calendar.google.com") || email.toLowerCase().endsWith("@group.calendar.google.com"));
            const isPurelyInternal = !allParticipants.some(p => !isInternalEntity(p));
            if (externalFilter && isPurelyInternal) continue;
            if (ignoreFromEmails.includes(organizerEmail) || attendees.some(a => ignoreToEmails.includes(a))) continue;
            
            let description = (event.description || "").replace(/<br\s*\/?>/gi, '\n').replace(/<p>/gi, '\n').replace(/<\/p>/gi, '\n').replace(/<[^>]*>/g, '');
            const hasMainTag = description.includes(tagPrefix);
            
            // --- FIX (v2.6.1): Separate Original vs. Suggested States ---
            let originalSeLead = seLeadTagText ? description.includes(seLeadTagText) : false;
            let originalInPerson = false;
            let originalTag = "";
            let hasSETagInDescription = false;
            
            let suggestedSeLead = originalSeLead;
            let suggestedInPerson = false; // This will be set by the tag logic
            let suggestedTag = "";

            let durationInMinutes = 0;
            if (event.end.dateTime && event.start.dateTime) {
                const eventStartTimeMs = new Date(event.start.dateTime).getTime();
                const eventEndTimeMs = new Date(event.end.dateTime).getTime();
                durationInMinutes = Math.round((eventEndTimeMs - eventStartTimeMs) / 60000);
            }

            if (hasMainTag) {
                const lines = description.split('\n');
                const tagLine = lines.find(line => line.trim().startsWith(tagPrefix));
                if (tagLine) {
                    hasSETagInDescription = tagLine.includes("(SE)");
                    let abbreviatedTag = tagLine.trim().substring(tagPrefix.length).trim();
                    if (modifier && abbreviatedTag.includes(modifier)) {
                      originalInPerson = true;
                    }
                    let lookupKey = abbreviatedTag.replace(modifier, "").replace(";", "").trim();
                    originalTag = tagMap.get(lookupKey) || "";
                    suggestedTag = originalTag;
                    suggestedInPerson = originalInPerson;
                }
            } else {
                // `originalTag` remains ""
                const searchText = (title + ' ' + description).toLowerCase();
                for (const [keyword, fullName] of keywordMap.entries()) {
                    if (searchText.includes(keyword)) {
                        if (fullName !== "CONFLICT") {
                             suggestedTag = fullName; // Set the suggestion
                        }
                        break;
                    }
                }
            }
            // --- END FIX ---
            
            const eventStartTime = new Date(event.start.dateTime || event.start.date);
            const hasExternalAttendee = !isPurelyInternal;
            
            const rowData = [
                title, eventStartTime, organizerEmail, hasExternalAttendee, 
                suggestedSeLead, suggestedInPerson, suggestedTag, // Visible: E, F, G
                '', // H: Synced Placeholder
                `=HYPERLINK("${event.htmlLink}", "Open Event")`, // I: Event Link
                '', // J: Last Refreshed Placeholder
                originalSeLead, originalInPerson, originalTag,   // K, L, M (Hidden Originals)
                durationInMinutes // N: Duration (Hidden)
            ];
            
            if (showTaggedMeetings) {
                if (hasMainTag) { fullyTaggedMeetings.push(rowData); } 
                else { noTagMeetings.push(rowData); }
            } else if (seTaggingMode) {
                if (hasSETagInDescription) { /* Hide */ } 
                else if (hasMainTag) { aeTaggedMeetings.push(rowData); } 
                else { noTagMeetings.push(rowData); }
            } else {
                if (!hasMainTag) { noTagMeetings.push(rowData); }
            }
        }
        
        // --- 5. Write Results ---
        const sheet = file.getSheets()[0];
        if (sheet.getLastRow() > 0) {
             sheet.getRange(1, 1, sheet.getMaxRows(), sheet.getMaxColumns()).clearContent().setBackground(null).setFontLine(null);
        }
        const headers = ["Title", "Start Time", "Created By", "External Attendees", "SE Lead", "In Person", "Add Tag to Meeting", "Synced", "Event Link", "Last Refreshed", "Original SE", "Original IP", "Original Tag", "Duration (min)"];
        sheet.getRange(1, 1, 1, headers.length).setValues([headers]);
        
        const finalList = [...noTagMeetings, ...aeTaggedMeetings, ...fullyTaggedMeetings];
        if (finalList.length > 0) { 
            sheet.getRange(2, 1, finalList.length, headers.length).setValues(finalList); 
            const numRows = finalList.length;
            const formulas = [];
            for (let i = 2; i <= numRows + 1; i++) {
                 // Formula now correctly compares G(7) to M(13), F(6) to L(12), E(5) to K(11)
                 formulas.push([`=AND(E${i}=K${i}, F${i}=L${i}, G${i}=M${i})`]);
            }
            sheet.getRange(2, 8, numRows, 1).setFormulas(formulas);
        }
        else { sheet.getRange("A2").setValue("No meetings found using your current criteria."); }
        
        // --- 6. Formatting ---
        _formatUntaggedSheet(sheet, headers, noTagMeetings, aeTaggedMeetings, fullyTaggedMeetings, { seTaggingMode, showTaggedMeetings, externalFilter, tagsData, tagBackgrounds });
        
    } catch (e) { SpreadsheetApp.getUi().alert(e.message); }
}

/**
 * The main worker function that updates the calendar.
 * WHY THE CHANGE (v2.6.1):
 * 1. The `tagMap` is now correctly FullName -> Abbreviation.
 * 2. The `hasChanged` logic now correctly checks all 3 editable fields (E, F, G).
 */
function updateMeetingTag(e, isSingleEditMode) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheet = isSingleEditMode ? e.range.getSheet() : ss.getSheets()[0];
  try {
    if (isSingleEditMode) {
      const range = e.range;
      if (range.getRow() <= 1) return;
      const editedCol = range.getColumn();
      const sheetName = sheet.getName();
      if (sheetName !== ss.getSheets()[0].getName()) return;

      if (editedCol === 5 || editedCol === 6) {
        if (e.value === "TRUE") range.setBackground('#d9ead3');
        else range.setBackground('#ffffff');
      }
      return; 
    }

    ss.toast("Processing batch... Please wait.");
    const tagPrefix = "Verkada Meeting Tag: ";
    const seLeadTag = getConfig("SELeadTagText");
    const modifier = getConfig("InPersonModifier");
    const lastRow = sheet.getLastRow();
    if (lastRow < 2) { ss.toast("No data to process."); return; }
    
    const tagsSheet = ss.getSheetByName("Tags");
    // --- THIS IS THE FIX (v2.6.1) ---
    // Read C and D, and map FullName (index 0) -> Abbreviation (index 1)
    const tagsData = tagsSheet.getRange("C2:D" + tagsSheet.getLastRow()).getValues();
    const tagMap = new Map(tagsData.map(row => [row[0], row[1]])); // FullName -> Abbreviation
    // --- END OF FIX ---

    const sheetData = sheet.getRange(2, 1, lastRow - 1, 14).getValues(); // Read 14 columns
    const calendarId = CalendarApp.getDefaultCalendar().getId();
    
    const eventTimes = sheetData.map(row => new Date(row[1]).getTime()).filter(t => !isNaN(t));
    if (eventTimes.length === 0) { ss.toast("No valid dates found to process."); return; }
    const minTime = new Date(Math.min(...eventTimes));
    const maxTime = new Date(Math.max(...eventTimes));
    maxTime.setHours(23, 59, 59);

    let allEventsForMap = [];
    let pageToken = null;
    do {
      const response = Calendar.Events.list(calendarId, { timeMin: minTime.toISOString(), timeMax: maxTime.toISOString(), singleEvents: true, maxResults: 2500, pageToken: pageToken });
      if (response.items) allEventsForMap = allEventsForMap.concat(response.items);
      pageToken = response.nextPageToken;
    } while (pageToken);

    const eventMap = new Map();
    allEventsForMap.forEach(event => eventMap.set(`${event.summary}_${new Date(event.start.dateTime || event.start.date).getTime()}`, event));

    const rowsToDelete = [];
    let updatedCount = 0;
    
    for (let i = 0; i < sheetData.length; i++) {
      const rowData = sheetData[i];
      const currentSeLead = rowData[4];    // Col E
      const currentInPerson = rowData[5];  // Col F
      const currentTag = rowData[6];       // Col G
      // Indices K, L, M are correct
      const originalSeLead = rowData[10];
      const originalInPerson = rowData[11];
      const originalTag = rowData[12];

      // --- FIX (v2.6.1): Check all three fields for changes ---
      const hasChanged = (currentSeLead !== originalSeLead) || (currentInPerson !== originalInPerson) || (currentTag !== originalTag);

      if (hasChanged && currentTag) {
        const title = rowData[0];
        const startTime = new Date(rowData[1]).getTime();
        const lookupKey = `${title}_${startTime}`;
        const eventToUpdate = eventMap.get(lookupKey);

        if (eventToUpdate) {
          let description = (eventToUpdate.description || "").replace(/<br\s*\/?>/gi, '\n').replace(/<p>|<\/p>/gi, '\n').replace(/<[^>]*>/g, '').trim();
          const seLeadRegex = new RegExp(`\\s*` + seLeadTag.trim() + `\\s*`, 'gi');
          description = description.replace(seLeadRegex, '').trim();
          if (currentSeLead) description += "\n" + seLeadTag;

          const aggressiveRemovalRegex = new RegExp(tagPrefix + ".*", "g");
          description = description.replace(aggressiveRemovalRegex, '');
          description = description.split('\n').filter(line => line.trim() !== '').join('\n').trim();

          let abbreviatedTag = tagMap.get(currentTag); // Look up abbreviation from the full name
          if (!abbreviatedTag) { SpreadsheetApp.getUi().alert(`Error: Tag "${currentTag}" not found in "Tags" sheet.`); continue; }
          
          if (currentInPerson && abbreviatedTag) {
            let suffix = abbreviatedTag.includes('(SE)') ? ' (SE)' : '';
            if(suffix) abbreviatedTag = abbreviatedTag.replace('(SE)', '');
            let coreTag = abbreviatedTag.replace(';', '').trim();
            abbreviatedTag = `${coreTag}${modifier}${suffix};`;
          }
          
          description += "\n\n" + tagPrefix + abbreviatedTag;
          Calendar.Events.patch({ description: description.trim() }, calendarId, eventToUpdate.id);
          rowsToDelete.push(i + 2);
          updatedCount++;
        }
      }
    }

    if (updatedCount > 0) {
      const numDataRows = lastRow - 1;
      if (updatedCount === numDataRows && rowsToDelete.length === numDataRows) {
        sheet.getRange(2, 1, numDataRows, sheet.getLastColumn()).clearContent();
      } else {
        rowsToDelete.sort((a, b) => b - a).forEach(rowNum => sheet.deleteRow(rowNum));
      }
      ss.toast(`${updatedCount} meeting(s) were successfully updated.`);
    } else {
      ss.toast("No changes were detected to apply.");
    }

  } catch (err) { SpreadsheetApp.getUi().alert(err.message); }
}
// #endregion

// =================================================================
// #region 4. HELPER & UTILITY FUNCTIONS
// =================================================================

function getConfig(label) {
  const configSheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("Config");
  if (!configSheet) throw new Error("The 'Config' sheet could not be found.");
  const finder = configSheet.createTextFinder(label).matchEntireCell(true).findNext();
  if (!finder) throw new Error(`Config label "${label}" not found in 'Config' sheet.`);
  return finder.offset(0, 1).getValue();
}

function _formatMinutesToHours(totalMinutes) {
  if (totalMinutes === 0) return "0min";
  const hours = Math.floor(totalMinutes / 60);
  const minutes = totalMinutes % 60;
  let result = "";
  if (hours > 0) result += `${hours}hr`;
  if (minutes > 0) result += ` ${minutes}min`;
  return result.trim();
}

function _formatUntaggedSheet(sheet, headers, noTagMeetings, aeTaggedMeetings, fullyTaggedMeetings, configs) {
    sheet.setFrozenRows(1);
    sheet.getRange(1, 1, 1, headers.length).setFontWeight("bold").setFontFamily('Poppins').setFontSize(11);
    sheet.getRange(1, 1, 1, headers.length).setBackground("#283e4d").setFontColor("white");
    
    const lastRow = sheet.getLastRow();
    const startRow = 2;
    if (lastRow > 1) {
        sheet.getRange(startRow, 2, lastRow - 1, 1).setNumberFormat("yyyy-mm-dd hh:mm AM/PM").setHorizontalAlignment("left");
        sheet.getRange(startRow, 1, lastRow - 1, headers.length).setFontFamily('Poppins').setFontSize(10);
        const extValues = sheet.getRange(startRow, 4, lastRow - 1, 1).getValues();
        sheet.getRange(startRow, 4, lastRow - 1, 1).setBackgrounds(extValues.map(([val]) => val === true ? ['#d9ead3'] : ['#f4cccc']));
    }
    
    sheet.getRange("J1").setValue(`Last Refreshed: ${new Date().toLocaleString()}`);
    sheet.setColumnWidth(3, 230);
    sheet.setColumnWidth(10, 300);
    sheet.hideColumns(11, 4); // Hide K, L, M, N

    if (lastRow > 1) {
        const syncedRange = sheet.getRange(startRow, 8, lastRow - 1, 1);
        let rules = sheet.getConditionalFormatRules();
        rules = rules.filter(r => r.getRanges()[0].getColumn() !== 8);
        rules.push(SpreadsheetApp.newConditionalFormatRule().whenTextEqualTo("TRUE").setBackground('#d9ead3').setFontColor('#38761d').setRanges([syncedRange]).build());
        rules.push(SpreadsheetApp.newConditionalFormatRule().whenTextEqualTo("FALSE").setBackground('#f4cccc').setFontColor('#cc0000').setRanges([syncedRange]).build());
        sheet.setConditionalFormatRules(rules);
    }

    if (configs.showTaggedMeetings) {
        if (noTagMeetings.length > 0) {
            sheet.getRange(startRow, 1, noTagMeetings.length, 3).setBackground('#f4cccc');
        }
    } else if (configs.seTaggingMode) {
        if (noTagMeetings.length > 0) {
            sheet.getRange(startRow, 1, noTagMeetings.length, 3).setBackground('#f4cccc');
        }
        if (aeTaggedMeetings.length > 0) {
            sheet.getRange(startRow + noTagMeetings.length, 1, aeTaggedMeetings.length, 3).setBackground('#fff2cc');
        }
    } else {
        if (noTagMeetings.length > 0) {
            sheet.getRange(startRow, 1, noTagMeetings.length, 3).setBackground('#f4cccc');
        }
    }
    
    if (fullyTaggedMeetings.length > 0) {
        const offset = noTagMeetings.length + aeTaggedMeetings.length;
        sheet.getRange(startRow + offset, 1, fullyTaggedMeetings.length, headers.length).setFontLine('line-through');
    }
}

// =================================================================
// #region 5. DYNAMIC QUARTER, ADMIN & VISUALS FUNCTIONS
// =================================================================

function _getDatesForVerkadaFQ(fiscalYear, quarter) {
  let startMonth, endMonth, startYear, endYear;
  const calendarYear = fiscalYear - 1;
  switch (quarter) {
    case 1: startMonth = 1; endMonth = 3; startYear = calendarYear; endYear = calendarYear; break;
    case 2: startMonth = 4; endMonth = 6; startYear = calendarYear; endYear = calendarYear; break;
    case 3: startMonth = 7; endMonth = 9; startYear = calendarYear; endYear = calendarYear; break;
    case 4: startMonth = 10; endMonth = 0; startYear = calendarYear; endYear = calendarYear + 1; break;
    default: throw new Error("Invalid quarter.");
  }
  const endDate = new Date(endYear, endMonth + 1, 0); endDate.setHours(23, 59, 59, 999);
  return { start: new Date(startYear, startMonth, 1), end: endDate };
}

function _getVerkadaFiscalQuarter(date) {
  const month = date.getMonth(), year = date.getFullYear();
  const fy = month >= 1 ? year + 1 : year;
  const q = (month >= 1 && month <= 3) ? 1 : (month >= 4 && month <= 6) ? 2 : (month >= 7 && month <= 9) ? 3 : 4;
  return { fiscalYear: fy, quarter: q, name: `FY${fy.toString().slice(-2)} Q${q}` };
}

function updateQuarterDropdown() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const configSheet = ss.getSheetByName("Config");
  if (!configSheet) throw new Error("'Config' sheet not found.");
  const finder = configSheet.createTextFinder("QuarterOverride").matchEntireCell(true).findNext();
  if (!finder) { ss.toast("Error: Label 'QuarterOverride' not found."); return; }
  
  const dropdownCell = finder.offset(0, 1);
  let quarters = ["None"];
  let today = new Date();
  for (let i = 0; i < 5; i++) {
    const fq = _getVerkadaFiscalQuarter(today);
    let name = fq.name;
    if (i === 0) name += " (Current)";
    quarters.push(name);
    const dates = _getDatesForVerkadaFQ(fq.fiscalYear, fq.quarter);
    today = new Date(dates.start.getTime() - 1);
  }
  finder.offset(0, 1).setDataValidation(SpreadsheetApp.newDataValidation().requireValueInList(quarters, true).setAllowInvalid(false).build());
  ss.toast("Quarter dropdown updated.");
}

/**
 * Admin function to build colored chip dropdowns.
 * WHY THE CHANGE (v2.6.1): This function is now fixed. It correctly
 * clears all rules, then re-adds the rules for the chips (Col G) AND
 * the rules for the 'Synced' column (Col H) at the same time.
 */
function updateTagDropdownsAndColors() {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const tagsSheet = ss.getSheetByName("Tags");
    const mainSheet = ss.getSheets()[0];
    if (!tagsSheet) { ss.toast("Error: 'Tags' sheet not found."); return; }
    ss.toast("Updating tag dropdowns and colors...");

    // 1. Read Tags and Colors from "Tags" sheet
    const lastTagRow = tagsSheet.getLastRow();
    const tagRawValues = tagsSheet.getRange("C2:C" + lastTagRow).getValues();
    const tagRawBackgrounds = tagsSheet.getRange("C2:C" + lastTagRow).getBackgrounds();
    const tagNames = [], tagColors = [];
    
    // Filter out blank rows to prevent errors
    for (let i = 0; i < tagRawValues.length; i++) {
        if (tagRawValues[i][0] && tagRawValues[i][0].trim() !== "") {
            tagNames.push([tagRawValues[i][0]]);
            tagColors.push([tagRawBackgrounds[i][0]]);
        }
    }

    // 2. Set up the dropdown validation (Column G)
    const dropdownRange = mainSheet.getRange(2, 7, mainSheet.getMaxRows() - 1, 1);
    dropdownRange.clearDataValidations();

    // 3. Use a helper sheet (the only reliable way for chips)
    const helperSheetName = "_TagListHelper";
    let helperSheet = ss.getSheetByName(helperSheetName);
    if (!helperSheet) { helperSheet = ss.insertSheet(helperSheetName).hideSheet(); } else { helperSheet.clear(); }

    if (tagNames.length > 0) {
        const helperRange = helperSheet.getRange(1, 1, tagNames.length, 1);
        helperRange.setValues(tagNames);
        helperRange.setBackgrounds(tagColors);
        dropdownRange.setDataValidation(SpreadsheetApp.newDataValidation().requireValueInRange(helperRange, true).setAllowInvalid(false).build());
    }

    // --- THIS IS THE FIX (v2.6.1) ---
    // 4. Wipe ALL conditional rules and rebuild them correctly
    mainSheet.clearConditionalFormatRules();
    let allRules = [];

    // 5. Build and add Chip Color rules (Col G)
    const dropdownRangeForRules = mainSheet.getRange(2, 7, mainSheet.getMaxRows() - 1, 1);
    tagNames.forEach((nameArr, i) => {
        allRules.push(SpreadsheetApp.newConditionalFormatRule().whenTextEqualTo(nameArr[0]).setBackground(tagColors[i][0]).setRanges([dropdownRangeForRules]).build());
    });

    // 6. Build and add Synced rules (Col H)
    const syncedRange = mainSheet.getRange(2, 8, mainSheet.getMaxRows() - 1, 1);
    allRules.push(SpreadsheetApp.newConditionalFormatRule().whenTextEqualTo("TRUE").setBackground('#d9ead3').setFontColor('#38761d').setRanges([syncedRange]).build());
    allRules.push(SpreadsheetApp.newConditionalFormatRule().whenTextEqualTo("FALSE").setBackground('#f4cccc').setFontColor('#cc0000').setRanges([syncedRange]).build());

    // 7. Apply all rules at once
    mainSheet.setConditionalFormatRules(allRules);
    // --- END OF FIX ---

    ss.toast("Tag dropdowns and colors updated successfully.");
}

function validateTagKeywords() {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const tagsSheet = ss.getSheetByName("Tags");
    if (!tagsSheet) { ss.toast("Error: 'Tags' sheet not found."); return; }
    ss.toast("Validating keywords...");

    const tagsData = tagsSheet.getRange("C2:E" + tagsSheet.getLastRow()).getValues();
    const tracker = new Map(), duplicates = new Map();

    tagsData.forEach(row => {
        if (row[0] && row[2]) {
            row[2].split(',').map(k => k.trim().toLowerCase()).filter(String).forEach(k => {
                if (tracker.has(k) && tracker.get(k) !== row[0]) {
                    if (!duplicates.has(k)) duplicates.set(k, [tracker.get(k)]);
                    duplicates.get(k).push(row[0]);
                } else { tracker.set(k, row[0]); }
            });
        }
    });

    if (duplicates.size === 0) { ss.toast("Success! All keywords are unique."); }
    else {
        let msg = "Warning: Duplicate keywords found!\n";
        for (const [k, t] of duplicates.entries()) { msg += `\n- "${k}": used by ${[...new Set(t)].join(', ')}`; }
        SpreadsheetApp.getUi().alert("Validation Failed", msg, SpreadsheetApp.getUi().ButtonSet.OK);
    }
}

function generateDashboard() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const dataSheet = ss.getSheets()[0];
  const visualsSheetName = "Visuals";
  let visualsSheet = ss.getSheetByName(visualsSheetName);
  if (!visualsSheet) { visualsSheet = ss.insertSheet(visualsSheetName); } 
  else { 
      visualsSheet.getCharts().forEach(c => visualsSheet.removeChart(c));
      visualsSheet.clear(); 
  }
  
  visualsSheet.showColumns(1, visualsSheet.getMaxColumns());
  visualsSheet.getRange("A1:Z1000").setFontFamily("Poppins").setFontSize(10);
  
  const lastRow = dataSheet.getLastRow();
  if (lastRow < 2) { SpreadsheetApp.getUi().alert("No data found in Untagged Meetings sheet."); return; }
  const data = dataSheet.getRange(2, 1, lastRow - 1, 14).getValues();
  
  let total = data.length, external = 0, seLead = 0, inPerson = 0, totalMinutes = 0;
  const tagCounts = new Map();
  const tagTime = new Map(); 

  data.forEach(row => {
    if (row[3] === true) external++;
    if (row[4] === true) seLead++;
    if (row[5] === true) inPerson++;
    
    const tagName = row[6];
    const duration = row[13];
    
    if (typeof duration === 'number') {
        totalMinutes += duration;
    }
    
    if (tagName && tagName.trim() !== "") { 
        tagCounts.set(tagName, (tagCounts.get(tagName) || 0) + 1);
        if (typeof duration === 'number') {
            tagTime.set(tagName, (tagTime.get(tagName) || 0) + duration);
        }
    }
  });
  let internal = total - external;

  // --- Scorecard Section (Rows 3-4) ---
  const scorecardTitles = ["Total Meetings", "External Meetings", "Internal Meetings", "SE Lead Mtgs", "In Person Mtgs", "Total Time Spent"];
  const scorecardValues = [total, external, internal, seLead, inPerson, _formatMinutesToHours(totalMinutes)];
  
  let currentCol = 1;
  for (let i = 0; i < scorecardTitles.length; i++) {
      visualsSheet.getRange(3, currentCol, 1, 2).merge().setValue(scorecardTitles[i]).setFontWeight("bold").setHorizontalAlignment("center").setBackground("#283e4d").setFontColor("white").setBorder(true, true, true, true, true, true);
      visualsSheet.getRange(4, currentCol, 1, 2).merge().setValue(scorecardValues[i]).setFontSize(15).setFontWeight("bold").setHorizontalAlignment("center").setBorder(true, true, true, true, true, true);
      currentCol += 2;
  }
  const scRange = visualsSheet.getRange(4, 1, 1, 10);
  let scRules = [
      SpreadsheetApp.newConditionalFormatRule().whenNumberLessThan(100).setFontColor("#38761d").setBold(true).setRanges([scRange]).build(),
      SpreadsheetApp.newConditionalFormatRule().whenNumberBetween(100, 150).setFontColor("#bf9000").setBold(true).setRanges([scRange]).build(),
      SpreadsheetApp.newConditionalFormatRule().whenNumberGreaterThan(150).setFontColor("#cc0000").setBold(true).setRanges([scRange]).build()
  ];
  visualsSheet.setConditionalFormatRules(scRules);

  // --- Interactive Tag Table (Starts at G6) ---
  // --- FIX (v2.6.1): Swapped J and K ---
  visualsSheet.getRange("G6").setValue("Hide").setFontWeight("bold").setBackground("#283e4d").setFontColor("white");
  visualsSheet.getRange("H6").setValue("Tag Name").setFontWeight("bold").setBackground("#283e4d").setFontColor("white");
  visualsSheet.getRange("I6").setValue("Count").setFontWeight("bold").setBackground("#283e4d").setFontColor("white");
  visualsSheet.getRange("J6").setValue("Percentage").setFontWeight("bold").setBackground("#283e4d").setFontColor("white");
  visualsSheet.getRange("K6").setValue("Total Time").setFontWeight("bold").setBackground("#283e4d").setFontColor("white");
  
  const sortedTags = [...tagCounts.entries()].sort((a, b) => b[1] - a[1]);
  if (sortedTags.length > 0) {
    const tableData = sortedTags.map(([tag, count]) => {
        const timeInMinutes = tagTime.get(tag) || 0;
        return [tag, count, timeInMinutes]; // Write raw minutes to Col J
    });
    
    visualsSheet.getRange(7, 8, tableData.length, 3).setValues(tableData); // Write H, I, J
    visualsSheet.getRange(7, 10, tableData.length, 1).setNumberFormat(`0" min"`); // Format Col J as minutes
    
    visualsSheet.getRange(7, 7, visualsSheet.getMaxRows() - 6, 1).removeCheckboxes();
    visualsSheet.getRange(7, 7, sortedTags.length, 1).insertCheckboxes();
    
    const numRows = sortedTags.length;
    const formulas = [];
    const timeFormulas = [];
    // Dynamic Formulas for Percentage (Col K) and Total Time (Col L, hidden)
    for (let i = 7; i < 7 + numRows; i++) {
        formulas.push([`=IF(G${i}=TRUE, "-", I${i}/SUMIF($G$7:$G,FALSE,$I$7:$I))`]); // Percentage
        timeFormulas.push([`=IF(G${i}=TRUE, 0, J${i})`]); // Total Time (for dynamic sum)
    }
    visualsSheet.getRange(7, 11, numRows, 1).setFormulas(formulas).setNumberFormat("0.0%"); // Percentage in Col K
    visualsSheet.getRange(7, 12, numRows, 1).setFormulas(timeFormulas); // Hidden sum data in Col L
    
    visualsSheet.getRange(6, 7, sortedTags.length + 1, 5).setBorder(true, true, true, true, true, true);
  }

  // --- Dynamic "Total Time Spent" Scorecard ---
  visualsSheet.getRange("L4").setFormula("=SUM(L7:L)");
  visualsSheet.getRange(3, 11, 1, 2).merge().setValue("Total Time Spent").setFontWeight("bold").setHorizontalAlignment("center").setBackground("#283e4d").setFontColor("white").setBorder(true, true, true, true, true, true);
  visualsSheet.getRange(4, 11, 1, 2).merge().setFormula(`=TEXT(L4/1440, "[h]'hr' m'min'")`).setFontSize(15).setFontWeight("bold").setHorizontalAlignment("center").setBorder(true, true, true, true, true, true);

  // Hidden Chart Source (now M, N)
  visualsSheet.getRange("M6").setValue("Chart Source (Hidden)").setFontStyle("italic");
  visualsSheet.getRange("M7").setFormula("=FILTER(H7:I, G7:G=FALSE)");
  visualsSheet.hideColumns(12, 3); // Hide L, M, N

  if (sortedTags.length > 0) {
    const chartRange = visualsSheet.getRange("M7:N" + (7 + sortedTags.length));
    const pieChart = visualsSheet.newChart().setChartType(Charts.ChartType.PIE).addRange(chartRange)
      .setOption('title', 'Meeting Tag Breakdown').setOption('pieSliceText', 'percentage').setOption('legend', { position: 'right' })
      .setOption('is3D', true)
      .setOption('colors', ['#283e4d', '#3d9fd2', '#757475', '#34545e', '#959ea7', '#546e7a', '#78909c', '#63c0f2', '#1f4e6a', '#de6662', '#c45551', '#e68a87'])
      .setOption('titleTextStyle', { fontName: 'Poppins', fontSize: 20, bold: true })
      .setOption('legend.textStyle', { fontName: 'Poppins', fontSize: 10 })
      .setOption('pieSliceTextStyle', { fontName: 'Poppins', color: 'white' })
      .setOption('height', 400).setOption('width', 700).setPosition(6, 1, 0, 0).build();
    visualsSheet.insertChart(pieChart);
  } else { visualsSheet.getRange("A6").setValue("No tagged meetings found."); }

  const selectedQuarter = getConfig("QuarterOverride");
  let dateString = `Last ${getConfig("DaysBack")} Days`;
  if (selectedQuarter && selectedQuarter !== "None") { dateString = selectedQuarter; }
  visualsSheet.getRange("A1").setValue(`Dashboard for: ${dateString} (Generated: ${new Date().toLocaleString()})`).setFontWeight("bold").setFontSize(12);

  visualsSheet.setColumnWidth(10, 120); // Col J (Total Time)
  visualsSheet.setColumnWidth(11, 120); // Col K (Percentage)
  visualsSheet.autoResizeColumns(7, 3); // Resize G, H, I
  ss.setActiveSheet(visualsSheet);
}
// #endregion
