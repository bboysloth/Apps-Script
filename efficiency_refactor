/**
 * @file Meeting Tagger Tool v6.1
 * @description This script provides tools to find, list, and batch-update Google Calendar events.
 * This version reverts the configuration loading mechanism to fix a critical bug in the
 * 'ExternalAttendees' filter, while retaining performance optimizations for batch updates.
 * @version 6.1.0
 */

// =================================================================
// #region 1. SPREADSHEET UI & MENU CREATION
// =================================================================
function onOpen() {
  SpreadsheetApp.getUi()
      .createMenu('Meeting Tools')
      .addItem('Save Config & Refresh', 'saveConfigAndRun')
      .addItem('Refresh Untagged List', 'findEventsMissingTag')
      .addSeparator()
      .addItem('Apply Changes to Calendar', 'applyBatchChanges')
      .addToUi();
}
// #endregion

// =================================================================
// #region 2. SCRIPT ENTRY POINTS (USER-TRIGGERED ACTIONS)
// =================================================================
function handleEdit(e) {
  updateMeetingTag(e, true); 
}

function applyBatchChanges() {
  updateMeetingTag(null, false); 
}

function saveConfigAndRun() {
  try {
    findEventsMissingTag();
    const file = SpreadsheetApp.getActiveSpreadsheet();
    const triggers = ScriptApp.getProjectTriggers();
    // Reverted to direct getConfig call to fix bug
    const minutes = parseInt(getConfig("MinutesInterval"), 10);

    triggers.forEach(trigger => {
      const handler = trigger.getHandlerFunction();
      if (handler === 'findEventsMissingTag') {
        ScriptApp.deleteTrigger(trigger);
      }
    });

    if (minutes > 0) {
      ScriptApp.newTrigger('findEventsMissingTag').timeBased().everyMinutes(minutes).create();
    }
    ScriptApp.newTrigger('findEventsMissingTag').forSpreadsheet(file).onOpen().create();
    SpreadsheetApp.getActiveSpreadsheet().toast("Configuration saved and list refreshed.");
  } catch (e) {
    SpreadsheetApp.getUi().alert(e.message);
  }
}
// #endregion

// =================================================================
// #region 3. CORE LOGIC FUNCTIONS (THE "BRAINS")
// =================================================================

/**
 * @description The main data-gathering function. Reads calendar based on "Config" sheet settings.
 * This version uses the original, reliable getConfig() method to ensure filters work correctly.
 */
function findEventsMissingTag() {
    const file = SpreadsheetApp.getActiveSpreadsheet();
    try {
        // --- 1. REVERTED: Read all configurations directly for reliability ---
        const daysBack = parseInt(getConfig("DaysBack"), 10);
        const daysAhead = parseInt(getConfig("DaysAhead"), 10);
        const ignorePhrases = (getConfig("IgnorePhrases") || "").split(",").map(s => s.trim()).filter(Boolean);
        const ignoreExact = (getConfig("IgnoreExactTitles") || "").split(",").map(s => s.trim()).filter(Boolean);
        const ignoreFromEmails = (getConfig("IgnoreFromEmails") || "").split(",").map(s => s.trim()).filter(Boolean);
        const ignoreToEmails = (getConfig("IgnoreToEmails") || "").split(",").map(s => s.trim()).filter(Boolean);
        const externalFilter = (getConfig("ExternalAttendees") || "false").toString().toLowerCase() === "true";
        const seTaggingMode = (getConfig("SETagMode") || "false").toString().toLowerCase() === "true";
        const showTaggedMeetings = (getConfig("ShowTaggedMeetings") || "false").toString().toLowerCase() === "true";
        const modifier = getConfig("InPersonModifier");
        const seLeadTagText = getConfig("SELeadTagText");
        const tagPrefix = "Verkada Meeting Tag: ";

        const tagsSheet = file.getSheetByName("Tags");
        const tagsData = tagsSheet.getRange("C2:D" + tagsSheet.getLastRow()).getValues();
        const tagMap = new Map(tagsData.map(row => [row[1].trim().replace(";", ""), row[0]]));
        
        // --- 2. Calculate precise date range ---
        const start = new Date();
        start.setHours(0, 0, 0, 0);
        start.setDate(start.getDate() - daysBack);

        const end = new Date();
        end.setHours(23, 59, 59, 999);
        end.setDate(end.getDate() + daysAhead);
        
        // --- 3. Fetch all calendar events ---
        const calendarId = CalendarApp.getDefaultCalendar().getId();
        const response = Calendar.Events.list(calendarId, { timeMin: start.toISOString(), timeMax: end.toISOString(), singleEvents: true, orderBy: 'startTime' });
        const events = response.items || [];
        
        const noTagMeetings = [], aeTaggedMeetings = [], fullyTaggedMeetings = [];

        // --- 4. Process each event in memory ---
        for (const event of events) {
            if (event.start.date) { continue; }
            if (!event.summary) continue;
            
            const title = event.summary;
            if (ignoreExact.includes(title) || ignorePhrases.some(p => title.includes(p))) continue;
            
            const organizerEmail = event.organizer ? event.organizer.email : (event.creator ? event.creator.email : '');
            if (externalFilter === false && organizerEmail.toLowerCase().endsWith('@group.calendar.google.com')) {
              continue;
            }

            const attendees = (event.attendees || []).map(a => a.email).filter(Boolean);
            const allParticipants = [...new Set([organizerEmail, ...attendees])];
            const isInternal = email => email && (email.toLowerCase().endsWith("@verkada.com") || email.toLowerCase().endsWith("@resource.calendar.google.com") || email.toLowerCase().endsWith("@group.calendar.google.com"));
            const isPurelyInternal = allParticipants.length > 0 && allParticipants.every(isInternal);
            
            // This is the original, working filter logic.
            if (externalFilter && isPurelyInternal) { continue; }
            
            if (ignoreFromEmails.includes(organizerEmail) || attendees.some(a => ignoreToEmails.includes(a))) continue;
            
            let description = (event.description || "").replace(/<br\s*\/?>/gi, '\n').
